#include "distance.h"

#define ADC_POWER   0x80 //ADC电源控制位
#define ADC_FLAG    0x10 //ADC完成标志
#define ADC_START   0x08 //ADC起始控制位
#define ADC_SPEEDLL 0x00 //540个时钟
#define ADC_SPEEDL  0x20 //360个时钟
#define ADC_SPEEDH  0x40 //180个时钟
#define ADC_SPEEDHH 0x60 //90个时钟

bit ADCflag = 0;

void quickSortAscending(u16 *arr, u8 length) {
    if (length <= 1) {
        return;
    }

    {
        // 选择中间元素作为基准
        u16 pivot = arr[length / 2];
        u8 i = 0;
        u8 j = length - 1;

        while (i <= j) {
            // 从左向右找到第一个大于等于基准的元素
            while (arr[i] < pivot) {
                i++;
            }
            // 从右向左找到第一个小于等于基准的元素
            while (arr[j] > pivot) {
                j--;
            }
            // 交换这两个元素
            if (i <= j) {
                u16 temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
                i++;
                j--;
            }
        }

        // 递归排序左右子数组
        if (j > 0) {
            quickSortAscending(arr, j + 1);
        }
        if (i < length - 1) {
            quickSortAscending(arr + i, length - i);
        }
    }
}

void adc_isr() INTERRUPT(5) USING(3) {
    ADC_CONTR &= ~ADC_FLAG; // 清除ADC中断标志
    ADCflag = 1;
}

// 初始化ADC
void Init_ADC() {
    P1ASF = 0x0e; // 设置P1低6位都为AD口
    ADC_RES = 0;  // 清除结果寄存器
    ADC_RESL = 0;
    ADC_CONTR = ADC_POWER | ADC_SPEEDLL | ADC_START;
}

// 读取ADC值
u16 getADCValue(u8 channel) {
    ADCflag = 0;
    ADC_CONTR = ADC_POWER | ADC_SPEEDLL | ADC_START | (channel & 0x07);
    while (~ADCflag);
    return (ADC_RES << 2) + (ADC_RESL & 0x03);
}

// 单位：毫米 mm
code u16 AD2DistanceTAB[431] = {
    856, 856, 856, 856, 856, 856, 844, 832, 821, 809, 799, 788, 778, 768, 758, 749,
    740, 730, 722, 713, 705, 697, 689, 681, 673, 666, 658, 651, 644, 637, 631, 624,
    618, 611, 605, 599, 593, 587, 582, 576, 571, 565, 560, 555, 550, 545, 540, 535,
    530, 525, 521, 516, 512, 508, 503, 499, 505, 499, 494, 488, 483, 478, 473, 468,
    463, 459, 454, 449, 445, 441, 436, 432, 428, 424, 420, 416, 412, 409, 405, 401,
    398, 394, 391, 387, 384, 381, 378, 375, 371, 368, 365, 362, 360, 357, 354, 351,
    348, 346, 343, 340, 338, 335, 333, 330, 328, 326, 323, 321, 319, 316, 314, 312,
    310, 308, 306, 304, 302, 300, 298, 296, 294, 292, 290, 288, 286, 284, 283, 281,
    279, 277, 276, 274, 272, 271, 269, 267, 266, 264, 263, 261, 260, 258, 257, 255,
    254, 252, 251, 250, 248, 247, 246, 244, 243, 242, 240, 239, 238, 236, 235, 234,
    233, 232, 230, 229, 228, 227, 226, 225, 223, 222, 221, 220, 219, 218, 217, 216,
    215, 214, 213, 212, 211, 210, 209, 208, 207, 206, 205, 204, 203, 202, 201, 201,
    200, 199, 198, 197, 196, 195, 194, 194, 193, 192, 191, 190, 189, 189, 188, 187,
    186, 186, 185, 184, 183, 183, 182, 181, 180, 180, 179, 178, 177, 177, 176, 175,
    175, 174, 173, 173, 172, 171, 171, 170, 169, 169, 168, 168, 167, 166, 166, 165,
    164, 164, 163, 163, 162, 161, 161, 160, 160, 159, 159, 158, 158, 157, 156, 156,
    155, 155, 154, 154, 153, 153, 152, 152, 151, 151, 150, 150, 149, 149, 148, 148,
    147, 147, 146, 146, 145, 145, 144, 144, 143, 143, 142, 142, 142, 141, 141, 140,
    140, 139, 139, 138, 138, 138, 137, 137, 136, 136, 136, 135, 135, 134, 134, 134,
    133, 133, 132, 132, 132, 131, 131, 130, 130, 130, 129, 129, 129, 128, 128, 127,
    127, 127, 126, 126, 126, 125, 125, 125, 124, 124, 124, 123, 123, 123, 122, 122,
    122, 121, 121, 121, 120, 120, 120, 119, 119, 119, 118, 118, 118, 117, 117, 117,
    116, 116, 116, 116, 115, 115, 115, 114, 114, 114, 114, 113, 113, 113, 112, 112,
    112, 112, 111, 111, 111, 110, 110, 110, 110, 109, 109, 109, 109, 108, 108, 108,
    108, 107, 107, 107, 106, 106, 106, 106, 105, 105, 105, 105, 104, 104, 104, 104,
    104, 103, 103, 103, 103, 102, 102, 102, 102, 101, 101, 101, 101, 100, 100, 100,
    100, 100, 99, 99, 99, 99, 98, 98, 98, 98, 98, 97, 97, 97, 97,
};

// ADC数值转距离 毫米mm
u16 ADValue2Distance(u16 ADValue) {
    if (ADValue > 500)
        ADValue = 500;
    if (ADValue < 70)
        ADValue = 70;

    return AD2DistanceTAB[ADValue];
    
    // if (ADValue > 125)
    //     return 220 / (ADValue * 0.004883 - 0.18);
    // else
    //     return 293 / (ADValue * 0.004883 - 0.024);
}
